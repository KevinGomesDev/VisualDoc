// ==========================================
// VisualDoc - Aplicativo de Documenta√ß√£o Visual
// ==========================================

class VisualDocApp {
  constructor() {
    this.cards = [];
    this.connections = [];
    this.texts = [];
    this.columns = [];
    this.categories = [
      { id: "cat-1", name: "Geral", color: "#6c5ce7" },
      { id: "cat-2", name: "Frontend", color: "#00b894" },
      { id: "cat-3", name: "Backend", color: "#e17055" },
      { id: "cat-4", name: "Design", color: "#fdcb6e" },
    ];

    // Unified selection state
    this.selectedItemId = null;
    this.selectedItemType = null; // 'card', 'text', 'column'
    this.selectedItemIds = []; // Multi-selection [{id, type}]
    this.clipboard = [];
    this.selectedCategoryIds = [];

    // Legacy compatibility
    this.selectedCardId = null;
    this.selectedCardIds = [];

    this.isDragging = false;
    this.isPanning = false;
    this.isConnecting = false;
    this.isDraggingConnector = false;
    this.isResizing = false;
    this.resizingCardId = null;
    this.resizeStart = { width: 0, height: 0, mouseX: 0, mouseY: 0 };
    this.dragOffset = { x: 0, y: 0 };
    this.panStart = { x: 0, y: 0 };
    this.connectingFromCard = null;
    this.connectingFromChecklist = null;
    this.zoom = 1;
    this.pan = { x: 0, y: 0 };

    // Connection manager (ser√° inicializado depois de bindElements)
    this.connectionManager = null;
    this.selectedConnectionIndex = null; // Para compatibilidade

    this.saveTimeout = null;
    this.currentProjectPath = null;
    this.projectName = null;

    // Context menu position for creating items
    this.contextMenuPosition = { x: 0, y: 0 };

    // Hist√≥rico para undo/redo
    this.history = [];
    this.historyIndex = -1;
    this.maxHistory = 50;
    this.isUndoRedo = false;

    this.init();
  }

  async init() {
    this.bindElements();
    this.bindEvents();
    this.loadTheme();

    // Inicializa o gerenciador de conex√µes
    this.connectionManager = new ConnectionManager(this);

    // Verifica se h√° um projeto aberto ou pede para criar/abrir um
    await this.checkOrCreateProject();

    this.render();
  }

  bindElements() {
    // Containers
    this.cardsContainer = document.getElementById("cards-container");
    this.connectionsLayer = document.getElementById("connections-layer");
    this.canvasContainer = document.getElementById("canvas-container");

    // Toolbar
    this.btnExport = document.getElementById("btn-export");
    this.btnToggleTheme = document.getElementById("btn-toggle-theme");
    this.btnNewProject = document.getElementById("btn-new-project");
    this.btnLoadProject = document.getElementById("btn-load-project");
    this.btnSaveProject = document.getElementById("btn-save-project");
    this.saveStatus = document.getElementById("save-status");
    this.themeIconDark = document.getElementById("theme-icon-dark");
    this.themeIconLight = document.getElementById("theme-icon-light");

    // Modal
    this.cardModal = document.getElementById("card-modal");
    this.modalTitle = document.getElementById("modal-title");
    this.cardTitleInput = document.getElementById("card-title");
    this.categoryButtons = document.getElementById("category-buttons");
    this.checklistsContainer = document.getElementById("checklists-container");
    this.cardDetailsInput = document.getElementById("card-details");
    this.btnCloseModal = document.getElementById("btn-close-modal");
    this.btnDeleteCard = document.getElementById("btn-delete-card");
    this.btnAddChecklist = document.getElementById("btn-add-checklist");

    // Categories Modal
    this.btnCategories = document.getElementById("btn-categories");
    this.categoriesModal = document.getElementById("categories-modal");
    this.btnCloseCategories = document.getElementById("btn-close-categories");
    this.btnCloseCategoriesFooter = document.getElementById(
      "btn-close-categories-footer",
    );
    this.newCategoryName = document.getElementById("new-category-name");
    this.newCategoryColor = document.getElementById("new-category-color");
    this.btnAddCategory = document.getElementById("btn-add-category");
    this.categoriesList = document.getElementById("categories-list");

    // Context Menu
    this.contextMenu = document.getElementById("context-menu");
    this.ctxConnect = document.getElementById("ctx-connect");
    this.ctxDisconnect = document.getElementById("ctx-disconnect");
    this.ctxEdit = document.getElementById("ctx-edit");
    this.ctxDelete = document.getElementById("ctx-delete");

    // Canvas Context Menu
    this.canvasContextMenu = document.getElementById("canvas-context-menu");
    this.ctxNewCard = document.getElementById("ctx-new-card");
    this.ctxNewText = document.getElementById("ctx-new-text");
    this.ctxNewColumn = document.getElementById("ctx-new-column");
  }

  bindEvents() {
    // Toolbar events
    this.btnExport.addEventListener("click", () => this.exportSVG());
    this.btnToggleTheme.addEventListener("click", () => this.toggleTheme());
    this.btnNewProject.addEventListener("click", () => this.newProject());
    this.btnLoadProject.addEventListener("click", () => this.loadProject());
    this.btnSaveProject.addEventListener("click", () => this.saveProjectAs());
    this.btnCategories.addEventListener("click", () =>
      this.openCategoriesModal(),
    );

    // Categories Modal events
    this.btnCloseCategories.addEventListener("click", () =>
      this.closeCategoriesModal(),
    );
    this.btnCloseCategoriesFooter.addEventListener("click", () =>
      this.closeCategoriesModal(),
    );
    this.btnAddCategory.addEventListener("click", () => this.addCategory());

    // Modal events
    this.btnCloseModal.addEventListener("click", () => this.closeModal());
    this.btnDeleteCard.addEventListener("click", () =>
      this.deleteSelectedCard(),
    );
    this.btnAddChecklist.addEventListener("click", () =>
      this.addChecklistInput(),
    );

    // Canvas events
    this.canvasContainer.addEventListener("mousedown", (e) =>
      this.onCanvasMouseDown(e),
    );
    this.canvasContainer.addEventListener("contextmenu", (e) =>
      this.onCanvasContextMenu(e),
    );
    document.addEventListener("mousemove", (e) => this.onMouseMove(e));
    document.addEventListener("mouseup", (e) => this.onMouseUp(e));
    this.canvasContainer.addEventListener("wheel", (e) => this.onWheel(e));

    // Context menu events
    this.ctxConnect.addEventListener("click", () => this.startConnecting());
    this.ctxDisconnect.addEventListener("click", () => this.disconnectCard());
    this.ctxEdit.addEventListener("click", () => this.editSelectedCard());
    this.ctxDelete.addEventListener("click", () => this.deleteSelectedCard());

    // Canvas context menu events
    this.ctxNewCard.addEventListener("click", () => this.createNewCard());
    this.ctxNewText.addEventListener("click", () => this.createNewText());
    this.ctxNewColumn.addEventListener("click", () => this.createNewColumn());

    // Close context menu on click outside
    document.addEventListener("click", (e) => {
      if (!this.contextMenu.contains(e.target)) {
        this.hideContextMenu();
      }
      if (!this.canvasContextMenu.contains(e.target)) {
        this.hideCanvasContextMenu();
      }
    });

    // Close modal on Escape, undo/redo, copy/paste
    document.addEventListener("keydown", (e) => {
      // Ignora se estiver em input/textarea
      if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") {
        if (e.key === "Escape") {
          this.closeModal();
          this.hideContextMenu();
          this.hideCanvasContextMenu();
        }
        return;
      }

      if (e.key === "Escape") {
        this.closeModal();
        this.hideContextMenu();
        this.hideCanvasContextMenu();
        this.cancelConnecting();
        this.clearSelection();
        this.deselectConnection();
      }
      // Undo: Ctrl+Z
      if (e.ctrlKey && e.key === "z") {
        e.preventDefault();
        this.undo();
      }
      // Redo: Ctrl+Y
      if (e.ctrlKey && e.key === "y") {
        e.preventDefault();
        this.redo();
      }
      // Copy: Ctrl+C
      if (e.ctrlKey && e.key === "c") {
        e.preventDefault();
        this.copySelectedCards();
      }
      // Paste: Ctrl+V
      if (e.ctrlKey && e.key === "v") {
        e.preventDefault();
        this.pasteCards();
      }
      // Select All: Ctrl+A
      if (e.ctrlKey && e.key === "a") {
        e.preventDefault();
        this.selectAllCards();
      }
      // Delete selected items or connection
      if (e.key === "Delete") {
        e.preventDefault();
        if (this.selectedConnectionIndex !== null) {
          this.deleteSelectedConnection();
        } else if (this.selectedItemIds.length > 0) {
          this.deleteSelectedItems();
        }
      }
    });
  }

  // ==========================================
  // Project Initialization
  // ==========================================

  async checkOrCreateProject() {
    // Verifica se j√° tem um projeto aberto
    const projectName = await window.electronAPI.getProjectName();

    if (projectName) {
      this.projectName = projectName;
      await this.loadData();
      return;
    }

    // Lista projetos existentes
    const result = await window.electronAPI.listProjects();
    const existingProjects = result.projects || [];

    // Mostra modal para criar ou abrir projeto
    await this.showProjectSelectionModal(existingProjects);
  }

  async showProjectSelectionModal(existingProjects) {
    return new Promise((resolve) => {
      // Cria modal de sele√ß√£o de projeto
      const modalOverlay = document.createElement("div");
      modalOverlay.className = "modal project-selection-modal";
      modalOverlay.innerHTML = `
        <div class="modal-content" style="max-width: 500px;">
          <div class="modal-header">
            <h2>ÔøΩ VisualDoc</h2>
          </div>
          <div class="modal-body" style="padding: 20px;">
            <div class="form-group" style="margin-bottom: 20px;">
              <label>Nome do Novo Projeto:</label>
              <input type="text" id="new-project-name" class="form-input" 
                     placeholder="Digite o nome do projeto..." 
                     style="width: 100%; padding: 10px; margin-top: 8px;">
            </div>
            <button id="btn-create-project" class="btn btn-primary" style="width: 100%; padding: 12px; font-size: 1rem;">
              ‚ú® Criar Novo Projeto
            </button>
            
            ${
              existingProjects.length > 0
                ? `
              <div style="margin-top: 25px; padding-top: 20px; border-top: 1px solid var(--border-color);">
                <label style="margin-bottom: 10px; display: block;">Ou abrir projeto existente:</label>
                <div class="existing-projects" style="max-height: 200px; overflow-y: auto;">
                  ${existingProjects
                    .map(
                      (name) => `
                    <button class="btn btn-secondary existing-project-btn" data-name="${name}" 
                            style="width: 100%; margin-bottom: 8px; text-align: left; padding: 10px;">
                      üìÅ ${name}
                    </button>
                  `,
                    )
                    .join("")}
                </div>
              </div>
            `
                : ""
            }
            
            <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--border-color);">
              <button id="btn-load-other-project" class="btn btn-secondary" style="width: 100%;">
                üìÇ Carregar outro arquivo .vdoc
              </button>
            </div>
          </div>
        </div>
      `;

      document.body.appendChild(modalOverlay);

      const nameInput = modalOverlay.querySelector("#new-project-name");
      const createBtn = modalOverlay.querySelector("#btn-create-project");
      const loadOtherBtn = modalOverlay.querySelector(
        "#btn-load-other-project",
      );

      // Foca no input
      setTimeout(() => nameInput.focus(), 100);

      // Criar novo projeto
      const createProject = async () => {
        const name = nameInput.value.trim();
        if (!name) {
          nameInput.style.borderColor = "var(--danger)";
          return;
        }

        // Remove caracteres inv√°lidos para nome de arquivo
        const safeName = name.replace(/[<>:"/\\|?*]/g, "-");

        const result = await window.electronAPI.setProjectName(safeName);
        this.projectName = safeName;

        // Carrega os dados iniciais do arquivo criado
        await this.loadData();

        modalOverlay.remove();
        resolve();
      };

      createBtn.addEventListener("click", createProject);
      nameInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") createProject();
      });

      // Abrir projeto existente da lista
      modalOverlay.querySelectorAll(".existing-project-btn").forEach((btn) => {
        btn.addEventListener("click", async () => {
          const name = btn.dataset.name;
          await window.electronAPI.setProjectName(name);
          this.projectName = name;
          await this.loadData();
          modalOverlay.remove();
          resolve();
        });
      });

      // Carregar outro arquivo
      loadOtherBtn.addEventListener("click", async () => {
        const result = await window.electronAPI.loadProject();
        if (result.success && result.data) {
          this.cards = result.data.cards || [];
          this.connections = result.data.connections || [];
          if (result.data.categories && result.data.categories.length > 0) {
            this.categories = result.data.categories;
          }
          this.projectName = result.projectName;
          this.currentProjectPath = result.filePath;
          modalOverlay.remove();
          resolve();
        }
      });
    });
  }

  // ==========================================
  // Data Management
  // ==========================================

  async loadData() {
    try {
      const result = await window.electronAPI.loadData();
      if (result.success && result.data) {
        this.cards = result.data.cards || [];
        this.connections = result.data.connections || [];
        this.texts = result.data.texts || [];
        this.columns = result.data.columns || [];

        // Migrate old connections to new format
        this.connections = this.connections.map((conn) => {
          if (!conn.id) {
            conn.id = `conn_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;
          }
          if (!conn.waypoints) {
            conn.waypoints = [];
          }
          if (!conn.fixedFromPoint) {
            conn.fixedFromPoint = null;
          }
          if (!conn.fixedToPoint) {
            conn.fixedToPoint = null;
          }
          return conn;
        });

        if (result.data.categories && result.data.categories.length > 0) {
          this.categories = result.data.categories;
        }
      }
      // Inicializa hist√≥rico com estado atual
      this.history = [
        {
          cards: JSON.parse(JSON.stringify(this.cards)),
          connections: JSON.parse(JSON.stringify(this.connections)),
          texts: JSON.parse(JSON.stringify(this.texts)),
          columns: JSON.parse(JSON.stringify(this.columns)),
          categories: JSON.parse(JSON.stringify(this.categories)),
        },
      ];
      this.historyIndex = 0;
    } catch (error) {
      console.error("Erro ao carregar dados:", error);
    }
  }

  async saveData() {
    // Debounce para evitar salvamentos excessivos
    if (this.saveTimeout) {
      clearTimeout(this.saveTimeout);
    }

    this.saveStatus.textContent = "‚è≥ Salvando...";
    this.saveStatus.classList.add("saving");

    this.saveTimeout = setTimeout(async () => {
      try {
        const data = {
          cards: this.cards,
          connections: this.connections,
          texts: this.texts,
          columns: this.columns,
          categories: this.categories,
          projectName: this.projectName,
          lastModified: new Date().toISOString(),
        };

        await window.electronAPI.saveData(data);

        this.saveStatus.textContent = "‚úì Salvo";
        this.saveStatus.classList.remove("saving");
      } catch (error) {
        console.error("Erro ao salvar dados:", error);
        this.saveStatus.textContent = "‚ùå Erro ao salvar";
      }
    }, 500);

    // Salva estado no hist√≥rico (para undo/redo)
    if (!this.isUndoRedo) {
      this.saveToHistory();
    }
  }

  saveToHistory() {
    // Remove estados futuros se estamos no meio do hist√≥rico
    if (this.historyIndex < this.history.length - 1) {
      this.history = this.history.slice(0, this.historyIndex + 1);
    }

    // Salva c√≥pia profunda do estado atual
    const state = {
      cards: JSON.parse(JSON.stringify(this.cards)),
      connections: JSON.parse(JSON.stringify(this.connections)),
      texts: JSON.parse(JSON.stringify(this.texts)),
      columns: JSON.parse(JSON.stringify(this.columns)),
      categories: JSON.parse(JSON.stringify(this.categories)),
    };

    this.history.push(state);

    // Limita tamanho do hist√≥rico
    if (this.history.length > this.maxHistory) {
      this.history.shift();
    } else {
      this.historyIndex++;
    }
  }

  undo() {
    if (this.historyIndex > 0) {
      this.historyIndex--;
      this.restoreFromHistory();
    }
  }

  redo() {
    if (this.historyIndex < this.history.length - 1) {
      this.historyIndex++;
      this.restoreFromHistory();
    }
  }

  restoreFromHistory() {
    const state = this.history[this.historyIndex];
    if (state) {
      this.isUndoRedo = true;
      this.cards = JSON.parse(JSON.stringify(state.cards));
      this.connections = JSON.parse(JSON.stringify(state.connections));
      this.texts = JSON.parse(JSON.stringify(state.texts || []));
      this.columns = JSON.parse(JSON.stringify(state.columns || []));
      if (state.categories) {
        this.categories = JSON.parse(JSON.stringify(state.categories));
      }
      this.render();

      // Salva no arquivo (mas n√£o adiciona ao hist√≥rico)
      this.saveDataWithoutHistory();
      this.isUndoRedo = false;
    }
  }

  async saveDataWithoutHistory() {
    if (this.saveTimeout) {
      clearTimeout(this.saveTimeout);
    }

    this.saveStatus.textContent = "‚è≥ Salvando...";
    this.saveStatus.classList.add("saving");

    this.saveTimeout = setTimeout(async () => {
      try {
        const data = {
          cards: this.cards,
          connections: this.connections,
          texts: this.texts,
          columns: this.columns,
          categories: this.categories,
          projectName: this.projectName,
          lastModified: new Date().toISOString(),
        };

        await window.electronAPI.saveData(data);

        this.saveStatus.textContent = "‚úì Salvo";
        this.saveStatus.classList.remove("saving");
      } catch (error) {
        console.error("Erro ao salvar dados:", error);
        this.saveStatus.textContent = "‚ùå Erro ao salvar";
      }
    }, 500);
  }

  // ==========================================
  // Card Management
  // ==========================================

  createNewCard() {
    const id = this.generateId();
    const containerRect = this.canvasContainer.getBoundingClientRect();

    // Usa a primeira categoria dispon√≠vel
    const defaultCategory = this.categories[0] || {
      id: "cat-1",
      name: "Geral",
      color: "#6c5ce7",
    };

    // Calculate position - use context menu position if available, otherwise center
    let x, y;
    if (this.contextMenuPosition.x !== 0 || this.contextMenuPosition.y !== 0) {
      x =
        (this.contextMenuPosition.x - containerRect.left - this.pan.x) /
        this.zoom;
      y =
        (this.contextMenuPosition.y - containerRect.top - this.pan.y) /
        this.zoom;
    } else {
      x = (containerRect.width / 2 - 140) / this.zoom - this.pan.x;
      y = (containerRect.height / 2 - 60) / this.zoom - this.pan.y;
    }

    const card = {
      id,
      title: "Novo Card",
      categoryIds: [defaultCategory.id],
      categoryId: defaultCategory.id, // Compatibilidade
      category: defaultCategory.name,
      details: "",
      color: defaultCategory.color,
      x,
      y,
      checklists: [],
    };

    this.cards.push(card);
    this.renderCard(card);
    this.saveData();
    this.hideCanvasContextMenu();

    // Abre modal para edi√ß√£o imediata
    this.selectedCardId = id;
    this.openModal(card);
  }

  createNewText() {
    const id = this.generateId();
    const containerRect = this.canvasContainer.getBoundingClientRect();

    // Calculate position - use context menu position if available, otherwise center
    let x, y;
    if (this.contextMenuPosition.x !== 0 || this.contextMenuPosition.y !== 0) {
      x =
        (this.contextMenuPosition.x - containerRect.left - this.pan.x) /
        this.zoom;
      y =
        (this.contextMenuPosition.y - containerRect.top - this.pan.y) /
        this.zoom;
    } else {
      x = (containerRect.width / 2 - 100) / this.zoom - this.pan.x;
      y = (containerRect.height / 2 - 20) / this.zoom - this.pan.y;
    }

    const text = {
      id,
      content: "Novo Texto",
      x,
      y,
      fontSize: 16,
      color: "#ffffff",
      width: 200,
    };

    this.texts.push(text);
    this.renderText(text);
    this.saveData();
    this.hideCanvasContextMenu();

    // Select and start editing
    this.selectItem(id, "text");
  }

  createNewColumn() {
    const id = this.generateId();
    const containerRect = this.canvasContainer.getBoundingClientRect();

    // Calculate position - use context menu position if available, otherwise center
    let x, y;
    if (this.contextMenuPosition.x !== 0 || this.contextMenuPosition.y !== 0) {
      x =
        (this.contextMenuPosition.x - containerRect.left - this.pan.x) /
        this.zoom;
      y =
        (this.contextMenuPosition.y - containerRect.top - this.pan.y) /
        this.zoom;
    } else {
      x = (containerRect.width / 2 - 150) / this.zoom - this.pan.x;
      y = (containerRect.height / 2 - 200) / this.zoom - this.pan.y;
    }

    const column = {
      id,
      x,
      y,
      width: 300,
      height: 200,
      color: "#6c5ce7",
    };

    this.columns.push(column);
    this.renderColumn(column);
    this.saveData();
    this.hideCanvasContextMenu();

    // Select the column
    this.selectItem(id, "column");
  }

  renderText(text) {
    const existingElement = document.getElementById(`text-${text.id}`);
    if (existingElement) {
      existingElement.remove();
    }

    const textElement = document.createElement("div");
    textElement.className = "canvas-text";
    textElement.id = `text-${text.id}`;
    textElement.style.left = `${text.x}px`;
    textElement.style.top = `${text.y}px`;
    textElement.style.fontSize = `${text.fontSize || 16}px`;
    textElement.style.color = text.color || "#ffffff";
    if (text.width) textElement.style.width = `${text.width}px`;
    textElement.contentEditable = "false";
    textElement.textContent = text.content || "Novo Texto";

    // Check if selected
    if (this.selectedItemId === text.id && this.selectedItemType === "text") {
      textElement.classList.add("selected");
    }

    // Add resize handle for font size
    const resizeHandle = document.createElement("div");
    resizeHandle.className = "text-resize-handle";
    textElement.appendChild(resizeHandle);

    // Events
    textElement.addEventListener("mousedown", (e) => {
      if (e.target.classList.contains("text-resize-handle")) return;
      this.onItemMouseDown(e, text.id, "text");
    });

    // Double click to edit text
    textElement.addEventListener("dblclick", (e) => {
      e.stopPropagation();
      textElement.contentEditable = "true";
      textElement.focus();
      // Select all text for easy editing
      const range = document.createRange();
      range.selectNodeContents(textElement);
      const sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    });

    textElement.addEventListener("blur", () => {
      textElement.contentEditable = "false";
      text.content = textElement.textContent;
      this.saveData();
    });

    textElement.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        textElement.blur();
      }
    });

    textElement.addEventListener("contextmenu", (e) =>
      this.onItemContextMenu(e, text.id, "text"),
    );

    // Resize handle for font size
    resizeHandle.addEventListener("mousedown", (e) => {
      e.stopPropagation();
      this.isResizing = true;
      this.resizingCardId = text.id;
      this.resizingItemType = "text";
      this.resizeStart = {
        fontSize: text.fontSize || 16,
        mouseY: e.clientY,
      };
    });

    this.cardsContainer.appendChild(textElement);
  }

  renderColumn(column) {
    const existingElement = document.getElementById(`column-${column.id}`);
    if (existingElement) {
      existingElement.remove();
    }

    const columnElement = document.createElement("div");
    columnElement.className = "canvas-column";
    columnElement.id = `column-${column.id}`;
    columnElement.style.left = `${column.x}px`;
    columnElement.style.top = `${column.y}px`;
    columnElement.style.width = `${column.width || 300}px`;
    columnElement.style.height = `${column.height || 400}px`;
    columnElement.style.backgroundColor = column.color || "#6c5ce7";

    // Check if selected
    if (
      this.selectedItemId === column.id &&
      this.selectedItemType === "column"
    ) {
      columnElement.classList.add("selected");
    }

    columnElement.innerHTML = `<div class="column-resize-handle"></div>`;

    // Events
    columnElement.addEventListener("mousedown", (e) => {
      if (!e.target.classList.contains("column-resize-handle")) {
        this.onItemMouseDown(e, column.id, "column");
      }
    });

    // Double click to change color
    columnElement.addEventListener("dblclick", (e) => {
      e.stopPropagation();
      this.openColumnColorPicker(column);
    });

    // Resize handle
    const resizeHandle = columnElement.querySelector(".column-resize-handle");
    resizeHandle.addEventListener("mousedown", (e) => {
      e.stopPropagation();
      this.isResizing = true;
      this.resizingCardId = column.id;
      this.resizingItemType = "column";
      this.resizeStart = {
        width: column.width || 300,
        height: column.height || 400,
        mouseX: e.clientX,
        mouseY: e.clientY,
      };
    });

    columnElement.addEventListener("contextmenu", (e) =>
      this.onItemContextMenu(e, column.id, "column"),
    );

    this.cardsContainer.appendChild(columnElement);
  }

  openColumnColorPicker(column) {
    // Create a temporary color input
    const colorInput = document.createElement("input");
    colorInput.type = "color";
    colorInput.value = column.color || "#6c5ce7";
    colorInput.style.position = "absolute";
    colorInput.style.opacity = "0";
    colorInput.style.pointerEvents = "none";
    document.body.appendChild(colorInput);

    colorInput.addEventListener("input", (e) => {
      column.color = e.target.value;
      const el = document.getElementById(`column-${column.id}`);
      if (el) el.style.backgroundColor = column.color;
    });

    colorInput.addEventListener("change", () => {
      this.saveData();
      colorInput.remove();
    });

    colorInput.addEventListener("blur", () => {
      colorInput.remove();
    });

    colorInput.click();
  }

  // Unified item selection
  selectItem(id, type) {
    this.clearSelection();
    this.selectedItemId = id;
    this.selectedItemType = type;
    this.selectedItemIds = [{ id, type }];

    // Legacy compatibility for cards
    if (type === "card") {
      this.selectedCardId = id;
      this.selectedCardIds = [id];
    }

    // Add visual selection
    const prefix =
      type === "card" ? "card" : type === "text" ? "text" : "column";
    const element = document.getElementById(`${prefix}-${id}`);
    if (element) {
      element.classList.add("selected");
    }
  }

  onItemMouseDown(e, itemId, itemType) {
    if (e.target.tagName === "INPUT") return;
    if (e.button === 2) return; // Right click

    // If clicking on an editable element that already has focus, allow editing
    const isEditingText =
      e.target.contentEditable === "true" &&
      document.activeElement === e.target;
    if (isEditingText) return;

    e.preventDefault();
    e.stopPropagation();

    // Handle connection mode for cards
    if (this.isConnecting && itemType === "card") {
      if (this.connectingFromCard !== itemId) {
        this.addConnection(this.connectingFromCard, itemId);
      }
      this.cancelConnecting();
      return;
    }

    // Deselect connections
    if (this.selectedConnectionIndex !== null) {
      this.deselectConnection();
    }

    // Multi-selection with Ctrl
    if (e.ctrlKey) {
      const idx = this.selectedItemIds.findIndex(
        (i) => i.id === itemId && i.type === itemType,
      );
      if (idx >= 0) {
        // Remove from selection
        this.selectedItemIds.splice(idx, 1);
        const prefix =
          itemType === "card"
            ? "card"
            : itemType === "text"
              ? "text"
              : "column";
        const element = document.getElementById(`${prefix}-${itemId}`);
        if (element) element.classList.remove("selected");

        // Legacy: sync selectedCardIds
        if (itemType === "card") {
          this.selectedCardIds = this.selectedCardIds.filter(
            (id) => id !== itemId,
          );
        }
      } else {
        // Add to selection
        this.selectedItemIds.push({ id: itemId, type: itemType });
        const prefix =
          itemType === "card"
            ? "card"
            : itemType === "text"
              ? "text"
              : "column";
        const element = document.getElementById(`${prefix}-${itemId}`);
        if (element) element.classList.add("selected");

        // Legacy: sync selectedCardIds
        if (itemType === "card") {
          this.selectedCardIds.push(itemId);
        }
      }
      this.selectedItemId = itemId;
      this.selectedItemType = itemType;
      if (itemType === "card") {
        this.selectedCardId = itemId;
      }
      return;
    }

    // Normal click - clear selection if item not selected
    const isSelected = this.selectedItemIds.some(
      (i) => i.id === itemId && i.type === itemType,
    );
    if (!isSelected) {
      this.clearSelection();
      this.selectedItemIds = [{ id: itemId, type: itemType }];
      this.selectedItemId = itemId;
      this.selectedItemType = itemType;

      // Legacy compatibility for cards
      if (itemType === "card") {
        this.selectedCardId = itemId;
        this.selectedCardIds = [itemId];
      }

      const prefix =
        itemType === "card" ? "card" : itemType === "text" ? "text" : "column";
      const element = document.getElementById(`${prefix}-${itemId}`);
      if (element) element.classList.add("selected");
    }

    // Start dragging
    this.isDragging = true;

    // Convert mouse coordinates to canvas space
    const canvasRect = this.canvasContainer.getBoundingClientRect();
    const canvasX = (e.clientX - canvasRect.left - this.pan.x) / this.zoom;
    const canvasY = (e.clientY - canvasRect.top - this.pan.y) / this.zoom;

    // Save offset for all selected items
    this.dragOffsets = {};
    this.selectedItemIds.forEach(({ id, type }) => {
      let item;
      if (type === "card") item = this.cards.find((c) => c.id === id);
      else if (type === "text") item = this.texts.find((t) => t.id === id);
      else if (type === "column") item = this.columns.find((c) => c.id === id);

      if (item) {
        this.dragOffsets[`${type}-${id}`] = {
          x: canvasX - item.x,
          y: canvasY - item.y,
          type,
        };
      }
    });

    // Mark all selected as dragging
    this.selectedItemIds.forEach(({ id, type }) => {
      const prefix =
        type === "card" ? "card" : type === "text" ? "text" : "column";
      const el = document.getElementById(`${prefix}-${id}`);
      if (el) el.classList.add("dragging");
    });
  }

  onItemContextMenu(e, itemId, itemType) {
    e.preventDefault();
    e.stopPropagation();

    this.selectItem(itemId, itemType);
    this.showContextMenu(e.clientX, e.clientY);
  }

  deleteItem(id, type) {
    if (type === "card") {
      this.deleteCard(id);
    } else if (type === "text") {
      this.texts = this.texts.filter((t) => t.id !== id);
      const el = document.getElementById(`text-${id}`);
      if (el) el.remove();
      this.saveData();
    } else if (type === "column") {
      this.columns = this.columns.filter((c) => c.id !== id);
      const el = document.getElementById(`column-${id}`);
      if (el) el.remove();
      this.saveData();
    }
  }

  renderCard(card) {
    const existingElement = document.getElementById(`card-${card.id}`);
    if (existingElement) {
      existingElement.remove();
    }

    const cardElement = document.createElement("div");
    cardElement.className = "card";
    cardElement.id = `card-${card.id}`;
    cardElement.style.left = `${card.x}px`;
    cardElement.style.top = `${card.y}px`;
    cardElement.style.borderColor = this.getCardPrimaryColor(card);

    // Aplica tamanho personalizado se existir
    if (card.width) cardElement.style.width = `${card.width}px`;
    if (card.height) cardElement.style.minHeight = `${card.height}px`;

    const completedCount = card.checklists.filter((c) => c.completed).length;
    const totalCount = card.checklists.length;
    const progress = totalCount > 0 ? (completedCount / totalCount) * 100 : 0;

    cardElement.innerHTML = `
      <div class="card-connector top" data-side="top" data-card-id="${card.id}"></div>
      <div class="card-connector bottom" data-side="bottom" data-card-id="${card.id}"></div>
      <div class="card-connector left" data-side="left" data-card-id="${card.id}"></div>
      <div class="card-connector right" data-side="right" data-card-id="${card.id}"></div>
      <div class="card-resize-handle"></div>
      ${card.details ? `<div class="card-tooltip">${this.escapeHtml(card.details)}</div>` : ""}
      <div class="card-header">
        <span class="card-title">${this.escapeHtml(card.title)}</span>
        <div class="card-categories">
          ${this.getCardCategories(card)
            .map(
              (cat) => `
            <span class="card-category" style="background-color: ${cat.color}20; color: ${cat.color}">
              ${this.escapeHtml(cat.name)}
            </span>
          `,
            )
            .join("")}
        </div>
      </div>
      ${
        card.checklists.length > 0
          ? `
        <div class="card-checklists">
          ${card.checklists
            .map((checklist) => {
              const itemCategory =
                checklist.categoryId !== null &&
                checklist.categoryId !== undefined
                  ? this.categories.find(
                      (c) => String(c.id) === String(checklist.categoryId),
                    )
                  : null;
              const itemStyle = itemCategory
                ? `border-left: 3px solid ${itemCategory.color}; background: linear-gradient(90deg, ${itemCategory.color}15 0%, transparent 100%);`
                : "";
              const categoryLabel = itemCategory
                ? `<span class="checklist-category-label" style="background-color: ${itemCategory.color}30; color: ${itemCategory.color}">${this.escapeHtml(itemCategory.name)}</span>`
                : "";
              return `
            <div class="card-checklist-item ${checklist.completed ? "completed" : ""}" 
                 data-checklist-id="${checklist.id}" 
                 data-card-id="${card.id}"
                 style="${itemStyle}">
              <div class="checklist-item-content">
                <input type="checkbox" ${checklist.completed ? "checked" : ""}>
                <span>${this.escapeHtml(checklist.name)}</span>
                ${categoryLabel}
              </div>
              <div class="checklist-connector" 
                   data-checklist-id="${checklist.id}" 
                   data-card-id="${card.id}"
                   title="Conectar"></div>
              ${checklist.details ? `<div class="checklist-tooltip">${this.escapeHtml(checklist.details)}</div>` : ""}
            </div>
          `;
            })
            .join("")}
        </div>
        <div class="card-progress">
          <div class="card-progress-bar" style="width: ${progress}%"></div>
        </div>
      `
          : ""
      }
    `;

    // Event listeners para o card
    cardElement.addEventListener("mousedown", (e) => {
      // Skip if clicking on connectors
      if (e.target.classList.contains("card-connector")) return;
      if (e.target.classList.contains("card-resize-handle")) return;
      this.onItemMouseDown(e, card.id, "card");
    });
    cardElement.addEventListener("dblclick", (e) =>
      this.onCardDoubleClick(e, card.id),
    );
    cardElement.addEventListener("contextmenu", (e) =>
      this.onCardContextMenu(e, card.id),
    );

    // Event listeners para checkboxes
    cardElement
      .querySelectorAll('.card-checklist-item input[type="checkbox"]')
      .forEach((checkbox, index) => {
        checkbox.addEventListener("change", (e) => {
          e.stopPropagation();
          this.toggleChecklist(
            card.id,
            card.checklists[index].id,
            checkbox.checked,
          );
        });
      });

    // Event listeners para conectores do card
    cardElement.querySelectorAll(".card-connector").forEach((connector) => {
      connector.addEventListener("mousedown", (e) =>
        this.onConnectorMouseDown(e, card.id),
      );
    });

    // Event listeners para conectores de checklist
    cardElement
      .querySelectorAll(".checklist-connector")
      .forEach((connector) => {
        connector.addEventListener("mousedown", (e) => {
          e.stopPropagation();
          const checklistId = connector.dataset.checklistId;
          const cardId = connector.dataset.cardId;
          this.onChecklistConnectorMouseDown(e, cardId, checklistId);
        });
      });

    // Event listener para resize
    const resizeHandle = cardElement.querySelector(".card-resize-handle");
    if (resizeHandle) {
      resizeHandle.addEventListener("mousedown", (e) =>
        this.onResizeMouseDown(e, card.id),
      );
    }

    this.cardsContainer.appendChild(cardElement);
  }

  toggleChecklist(cardId, checklistId, completed) {
    const card = this.cards.find((c) => c.id === cardId);
    if (card) {
      const checklist = card.checklists.find((c) => c.id === checklistId);
      if (checklist) {
        checklist.completed = completed;
        this.renderCard(card);
        this.saveData();
      }
    }
  }

  updateCardPosition(cardId, x, y) {
    const card = this.cards.find((c) => c.id === cardId);
    if (card) {
      card.x = x;
      card.y = y;
      this.saveData();
    }
  }

  deleteCard(cardId) {
    this.cards = this.cards.filter((c) => c.id !== cardId);
    // Remove conex√µes usando fromCardId/toCardId para suportar conex√µes de checklist
    this.connections = this.connections.filter((conn) => {
      const fromCard = conn.fromCardId || conn.from;
      const toCard = conn.toCardId || conn.to;
      return fromCard !== cardId && toCard !== cardId;
    });

    const element = document.getElementById(`card-${cardId}`);
    if (element) {
      element.remove();
    }

    this.renderConnections();
    this.saveData();
  }

  // ==========================================
  // Connection Management
  // ==========================================

  addConnection(
    fromCardId,
    toCardId,
    fromChecklistId = null,
    toChecklistId = null,
  ) {
    // Cria identificadores √∫nicos para a conex√£o
    const fromId = fromChecklistId
      ? `${fromCardId}:${fromChecklistId}`
      : fromCardId;
    const toId = toChecklistId ? `${toCardId}:${toChecklistId}` : toCardId;

    // Evita conex√µes duplicadas
    const exists = this.connections.some(
      (conn) =>
        (conn.from === fromId && conn.to === toId) ||
        (conn.from === toId && conn.to === fromId),
    );

    if (!exists && fromId !== toId) {
      this.connections.push({
        id: `conn_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`,
        from: fromId,
        to: toId,
        fromCardId: fromCardId,
        toCardId: toCardId,
        fromChecklistId: fromChecklistId,
        toChecklistId: toChecklistId,
        waypoints: [],
        fixedFromPoint: null,
        fixedToPoint: null,
      });
      this.renderConnections();
      this.saveData();
    }
  }

  removeConnection(fromId, toId) {
    this.connections = this.connections.filter(
      (conn) =>
        !(conn.from === fromId && conn.to === toId) &&
        !(conn.from === toId && conn.to === fromId),
    );
    this.renderConnections();
    this.saveData();
  }

  removeAllConnectionsFromCard(cardId) {
    this.connections = this.connections.filter(
      (conn) => conn.fromCardId !== cardId && conn.toCardId !== cardId,
    );
    this.renderConnections();
    this.saveData();
  }

  selectConnection(index) {
    if (this.connectionManager) {
      this.connectionManager.select(index);
    }
    this.selectedConnectionIndex = index;
  }

  deselectConnection() {
    if (this.connectionManager) {
      this.connectionManager.deselect();
    }
    this.selectedConnectionIndex = null;
  }

  renderConnections() {
    if (this.connectionManager) {
      this.connectionManager.render();
    }
  }

  // ==========================================
  // Mouse Events
  // ==========================================

  onCanvasMouseDown(e) {
    // Ignora se clicou em controles de conex√£o
    if (
      e.target.closest(".waypoint-handle") ||
      e.target.closest(".endpoint-handle") ||
      e.target.closest(".add-waypoint-btn") ||
      e.target.closest(".connection-hit-area")
    ) {
      return;
    }

    // Se clicou no fundo, inicia pan
    if (
      e.target === this.canvasContainer ||
      e.target === this.cardsContainer ||
      e.target.id === "connections-layer" ||
      e.target.closest("#connections-layer")
    ) {
      this.hideContextMenu();
      this.hideCanvasContextMenu();

      // Se est√° no modo de conex√£o, cancela
      if (this.isConnecting) {
        this.cancelConnecting();
        return;
      }

      // Limpa sele√ß√£o ao clicar no fundo (se n√£o for Ctrl)
      if (!e.ctrlKey) {
        this.clearSelection();
        // Tamb√©m deseleciona conex√£o
        if (this.connectionManager) {
          this.connectionManager.deselect();
        }
      }

      // Inicia pan da c√¢mera
      if (e.button === 0) {
        this.isPanning = true;
        this.panStart = {
          x: e.clientX - this.pan.x,
          y: e.clientY - this.pan.y,
        };
        this.canvasContainer.style.cursor = "grabbing";
      }
    }
  }

  onCardMouseDown(e, cardId) {
    if (e.target.classList.contains("card-connector")) return;
    if (e.target.tagName === "INPUT") return;
    if (e.button === 2) return; // Right click

    e.preventDefault();

    if (this.isConnecting) {
      // Se estamos no modo de conex√£o, conecta os cards
      if (this.connectingFromCard !== cardId) {
        this.addConnection(this.connectingFromCard, cardId);
      }
      this.cancelConnecting();
      return;
    }

    // Multi-sele√ß√£o com Ctrl
    if (e.ctrlKey) {
      if (this.selectedCardIds.includes(cardId)) {
        // Remove da sele√ß√£o
        this.selectedCardIds = this.selectedCardIds.filter(
          (id) => id !== cardId,
        );
        const cardElement = document.getElementById(`card-${cardId}`);
        if (cardElement) cardElement.classList.remove("selected");
      } else {
        // Adiciona √† sele√ß√£o
        this.selectedCardIds.push(cardId);
        const cardElement = document.getElementById(`card-${cardId}`);
        if (cardElement) cardElement.classList.add("selected");
      }
      this.selectedCardId = cardId;
      return;
    }

    // Clique normal - limpa sele√ß√£o se o card n√£o est√° selecionado
    if (!this.selectedCardIds.includes(cardId)) {
      this.clearSelection();
      this.selectedCardIds = [cardId];
    }

    this.isDragging = true;
    this.selectedCardId = cardId;

    const card = this.cards.find((c) => c.id === cardId);
    const cardElement = document.getElementById(`card-${cardId}`);

    // Convert mouse coordinates to canvas space (accounting for zoom/pan)
    const canvasRect = this.canvasContainer.getBoundingClientRect();
    const canvasX = (e.clientX - canvasRect.left - this.pan.x) / this.zoom;
    const canvasY = (e.clientY - canvasRect.top - this.pan.y) / this.zoom;

    // Salva offset para cada card selecionado
    this.dragOffsets = {};
    this.selectedCardIds.forEach((id) => {
      const c = this.cards.find((card) => card.id === id);
      if (c) {
        this.dragOffsets[id] = {
          x: canvasX - c.x,
          y: canvasY - c.y,
        };
      }
    });

    this.dragOffset = {
      x: canvasX - card.x,
      y: canvasY - card.y,
    };

    // Marca todos os selecionados como dragging
    this.selectedCardIds.forEach((id) => {
      const el = document.getElementById(`card-${id}`);
      if (el) el.classList.add("dragging", "selected");
    });
  }

  onCardDoubleClick(e, cardId) {
    e.preventDefault();
    const card = this.cards.find((c) => c.id === cardId);
    if (card) {
      this.selectedCardId = cardId;
      this.openModal(card);
    }
  }

  onCardContextMenu(e, cardId) {
    e.preventDefault();
    this.selectedCardId = cardId;
    this.showContextMenu(e.clientX, e.clientY);
  }

  onCanvasContextMenu(e) {
    // Se clicou no fundo (n√£o em um card), mostra menu do canvas
    if (
      e.target === this.canvasContainer ||
      e.target === this.cardsContainer ||
      e.target.id === "connections-layer"
    ) {
      e.preventDefault();
      this.hideContextMenu(); // Esconde menu de card se estiver aberto
      this.showCanvasContextMenu(e.clientX, e.clientY);
    }
  }

  onConnectorMouseDown(e, cardId) {
    e.preventDefault();
    e.stopPropagation();
    this.isDraggingConnector = true;
    this.connectingFromChecklist = null;
    this.startConnectingFrom(cardId);
  }

  onChecklistConnectorMouseDown(e, cardId, checklistId) {
    e.preventDefault();
    e.stopPropagation();
    this.isDraggingConnector = true;
    this.connectingFromChecklist = checklistId;
    this.startConnectingFrom(cardId, checklistId);
  }

  onResizeMouseDown(e, cardId) {
    e.preventDefault();
    e.stopPropagation();

    const cardElement = document.getElementById(`card-${cardId}`);
    if (!cardElement) return;

    this.isResizing = true;
    this.resizingCardId = cardId;
    this.resizeStart = {
      width: cardElement.offsetWidth,
      height: cardElement.offsetHeight,
      mouseX: e.clientX,
      mouseY: e.clientY,
    };

    cardElement.classList.add("resizing");
  }

  onMouseMove(e) {
    // Desenha linha tempor√°ria durante cria√ß√£o de conex√£o
    if (
      this.isDraggingConnector &&
      this.isConnecting &&
      this.connectingFromCard
    ) {
      this.updateTempConnectionLine(e);
    }

    // Resize de card, column ou text
    if (this.isResizing && this.resizingCardId) {
      // Handle text resize (font size)
      if (this.resizingItemType === "text") {
        const text = this.texts.find((t) => t.id === this.resizingCardId);
        const textElement = document.getElementById(
          `text-${this.resizingCardId}`,
        );
        if (text && textElement) {
          const deltaY = (e.clientY - this.resizeStart.mouseY) / this.zoom;
          const newFontSize = Math.max(
            6,
            this.resizeStart.fontSize + deltaY * 0.5,
          );
          text.fontSize = newFontSize;
          textElement.style.fontSize = `${newFontSize}px`;
        }
        return;
      }

      // Handle column resize
      if (this.resizingItemType === "column") {
        const column = this.columns.find((c) => c.id === this.resizingCardId);
        const columnElement = document.getElementById(
          `column-${this.resizingCardId}`,
        );
        if (column && columnElement) {
          const deltaX = (e.clientX - this.resizeStart.mouseX) / this.zoom;
          const deltaY = (e.clientY - this.resizeStart.mouseY) / this.zoom;
          const newWidth = Math.max(100, this.resizeStart.width + deltaX);
          const newHeight = Math.max(100, this.resizeStart.height + deltaY);
          column.width = newWidth;
          column.height = newHeight;
          columnElement.style.width = `${newWidth}px`;
          columnElement.style.height = `${newHeight}px`;
        }
        return;
      }

      // Handle card resize
      const card = this.cards.find((c) => c.id === this.resizingCardId);
      const cardElement = document.getElementById(
        `card-${this.resizingCardId}`,
      );

      if (card && cardElement) {
        const deltaX = (e.clientX - this.resizeStart.mouseX) / this.zoom;
        const deltaY = (e.clientY - this.resizeStart.mouseY) / this.zoom;

        const newWidth = Math.max(200, this.resizeStart.width + deltaX);
        const newHeight = Math.max(100, this.resizeStart.height + deltaY);

        cardElement.style.width = `${newWidth}px`;
        cardElement.style.minHeight = `${newHeight}px`;
        card.width = newWidth;
        card.height = newHeight;

        this.renderConnections();
      }
      return;
    }

    // Pan da c√¢mera
    if (this.isPanning) {
      this.pan.x = e.clientX - this.panStart.x;
      this.pan.y = e.clientY - this.panStart.y;
      this.applyTransform();
      return;
    }

    // Arrastar items (cards, texts, columns)
    if (this.isDragging && this.selectedItemIds.length > 0) {
      // Convert mouse coordinates to canvas space
      const canvasRect = this.canvasContainer.getBoundingClientRect();
      const canvasX = (e.clientX - canvasRect.left - this.pan.x) / this.zoom;
      const canvasY = (e.clientY - canvasRect.top - this.pan.y) / this.zoom;

      this.selectedItemIds.forEach(({ id, type }) => {
        let item, element;
        const offsetKey = `${type}-${id}`;
        const offset = this.dragOffsets?.[offsetKey];

        if (type === "card") {
          item = this.cards.find((c) => c.id === id);
          element = document.getElementById(`card-${id}`);
        } else if (type === "text") {
          item = this.texts.find((t) => t.id === id);
          element = document.getElementById(`text-${id}`);
        } else if (type === "column") {
          item = this.columns.find((c) => c.id === id);
          element = document.getElementById(`column-${id}`);
        }

        if (item && element && offset) {
          item.x = canvasX - offset.x;
          item.y = canvasY - offset.y;

          element.style.left = `${item.x}px`;
          element.style.top = `${item.y}px`;
        }
      });

      this.renderConnections();
    }
  }

  onMouseUp(e) {
    // Finaliza resize
    if (this.isResizing && this.resizingCardId) {
      const cardElement = document.getElementById(
        `card-${this.resizingCardId}`,
      );
      if (cardElement) {
        cardElement.classList.remove("resizing");
      }
      this.isResizing = false;
      this.resizingCardId = null;
      this.resizingItemType = null;
      this.saveData();
      return;
    }

    // Finaliza pan
    if (this.isPanning) {
      this.isPanning = false;
      this.canvasContainer.style.cursor = "default";
    }

    // Finaliza conex√£o por drag
    if (this.isDraggingConnector && this.isConnecting) {
      // Usa elementsFromPoint para encontrar elementos por baixo de linhas SVG
      const elements = document.elementsFromPoint(e.clientX, e.clientY);

      // Procura por connectors em todos os elementos
      let checklistConnector = null;
      let cardConnector = null;
      let cardElement = null;

      for (const el of elements) {
        if (
          !checklistConnector &&
          el.classList?.contains("checklist-connector")
        ) {
          checklistConnector = el;
        }
        if (!cardConnector && el.classList?.contains("card-connector")) {
          cardConnector = el;
        }
        if (!cardElement && el.classList?.contains("card")) {
          cardElement = el;
        }
      }

      if (checklistConnector) {
        // Conectar a um checklist
        const targetChecklistId = checklistConnector.dataset.checklistId;
        const targetCardId = checklistConnector.dataset.cardId;

        if (targetCardId && targetChecklistId) {
          // Evita conectar ao mesmo item
          if (
            !(
              targetCardId === this.connectingFromCard &&
              targetChecklistId === this.connectingFromChecklist
            )
          ) {
            this.addConnection(
              this.connectingFromCard,
              targetCardId,
              this.connectingFromChecklist,
              targetChecklistId,
            );
          }
        }
      } else if (cardConnector) {
        // Conectar a um card (via bolinha)
        const targetCardId = cardConnector.dataset.cardId;

        if (targetCardId && targetCardId !== this.connectingFromCard) {
          this.addConnection(
            this.connectingFromCard,
            targetCardId,
            this.connectingFromChecklist,
            null,
          );
        }
      } else if (cardElement) {
        const targetCardId = cardElement.id.replace("card-", "");
        // Evita conectar ao mesmo card quando n√£o h√° checklist envolvido
        if (
          targetCardId !== this.connectingFromCard ||
          this.connectingFromChecklist
        ) {
          this.addConnection(
            this.connectingFromCard,
            targetCardId,
            this.connectingFromChecklist,
            null,
          );
        }
      }
      this.cancelConnecting();
      this.isDraggingConnector = false;
    }

    // Finaliza drag de items (cards, texts, columns)
    if (this.isDragging && this.selectedItemIds.length > 0) {
      this.selectedItemIds.forEach(({ id, type }) => {
        const prefix =
          type === "card" ? "card" : type === "text" ? "text" : "column";
        const element = document.getElementById(`${prefix}-${id}`);
        if (element) {
          element.classList.remove("dragging");
        }
      });
      this.dragOffsets = {};
      this.saveData();
    }
    this.isDragging = false;
    this.resizingItemType = null;
  }

  onWheel(e) {
    e.preventDefault();
    const delta = e.deltaY > 0 ? -0.1 : 0.1;
    this.adjustZoom(delta);
  }

  // ==========================================
  // Connection Mode
  // ==========================================

  startConnecting() {
    this.hideContextMenu();
    this.startConnectingFrom(this.selectedCardId);
  }

  startConnectingFrom(cardId, checklistId = null) {
    this.isConnecting = true;
    this.connectingFromCard = cardId;
    this.connectingFromChecklist = checklistId;
    this.canvasContainer.classList.add("connecting-mode");

    const cardElement = document.getElementById(`card-${cardId}`);
    if (cardElement) {
      cardElement.classList.add("connecting");

      // Se est√° conectando de um checklist, destaca o item
      if (checklistId) {
        const checklistItem = cardElement.querySelector(
          `[data-checklist-id="${checklistId}"]`,
        );
        if (checklistItem) {
          checklistItem.classList.add("connecting");
        }
      }
    }
  }

  cancelConnecting() {
    this.isConnecting = false;
    this.canvasContainer.classList.remove("connecting-mode");

    // Remove linha tempor√°ria
    this.removeTempConnectionLine();

    if (this.connectingFromCard) {
      const cardElement = document.getElementById(
        `card-${this.connectingFromCard}`,
      );
      if (cardElement) {
        cardElement.classList.remove("connecting");
        // Remove destaque do checklist
        cardElement
          .querySelectorAll(".card-checklist-item.connecting")
          .forEach((item) => {
            item.classList.remove("connecting");
          });
      }
    }
    this.connectingFromCard = null;
    this.connectingFromChecklist = null;
  }

  updateTempConnectionLine(e) {
    // Calcula posi√ß√£o de origem
    const cardElement = document.getElementById(
      `card-${this.connectingFromCard}`,
    );
    if (!cardElement) return;

    const card = this.cards.find((c) => c.id === this.connectingFromCard);
    if (!card) return;

    let fromX, fromY;

    if (this.connectingFromChecklist) {
      // Conectando de um checklist
      const checklistItem = cardElement.querySelector(
        `[data-checklist-id="${this.connectingFromChecklist}"]`,
      );
      if (checklistItem) {
        const connector = checklistItem.querySelector(".checklist-connector");
        if (connector) {
          const cardRect = cardElement.getBoundingClientRect();
          const connRect = connector.getBoundingClientRect();
          fromX =
            card.x +
            (connRect.left - cardRect.left + connRect.width / 2) / this.zoom;
          fromY =
            card.y +
            (connRect.top - cardRect.top + connRect.height / 2) / this.zoom;
        }
      }
    }

    // Se n√£o tem checklist, usa o centro do card
    if (fromX === undefined) {
      fromX = card.x + (cardElement.offsetWidth || 280) / 2;
      fromY = card.y + (cardElement.offsetHeight || 100) / 2;
    }

    // Calcula posi√ß√£o do mouse no canvas
    const canvasRect = this.canvasContainer.getBoundingClientRect();
    const toX = (e.clientX - canvasRect.left - this.pan.x) / this.zoom;
    const toY = (e.clientY - canvasRect.top - this.pan.y) / this.zoom;

    // Cria ou atualiza a linha tempor√°ria
    let tempLine = this.connectionsLayer.querySelector(".temp-connection-line");
    if (!tempLine) {
      tempLine = document.createElementNS("http://www.w3.org/2000/svg", "path");
      tempLine.setAttribute("class", "temp-connection-line");
      tempLine.style.stroke = this.getCardPrimaryColor(card);
      tempLine.style.strokeWidth = "3";
      tempLine.style.fill = "none";
      tempLine.style.strokeDasharray = "8 4";
      tempLine.style.pointerEvents = "none";
      this.connectionsLayer.appendChild(tempLine);
    }

    // Desenha curva bezier
    const dx = toX - fromX;
    const dy = toY - fromY;
    let pathD;

    if (Math.abs(dx) > Math.abs(dy)) {
      const midX = (fromX + toX) / 2;
      pathD = `M ${fromX} ${fromY} C ${midX} ${fromY}, ${midX} ${toY}, ${toX} ${toY}`;
    } else {
      const midY = (fromY + toY) / 2;
      pathD = `M ${fromX} ${fromY} C ${fromX} ${midY}, ${toX} ${midY}, ${toX} ${toY}`;
    }

    tempLine.setAttribute("d", pathD);
  }

  removeTempConnectionLine() {
    const tempLine = this.connectionsLayer?.querySelector(
      ".temp-connection-line",
    );
    if (tempLine) {
      tempLine.remove();
    }
  }

  disconnectCard() {
    this.hideContextMenu();
    if (this.selectedCardId) {
      this.removeAllConnectionsFromCard(this.selectedCardId);
    }
  }

  // ==========================================
  // Context Menu
  // ==========================================

  showContextMenu(x, y) {
    this.hideCanvasContextMenu(); // Esconde menu do canvas se estiver aberto
    this.contextMenu.classList.remove("hidden");
    this.contextMenu.style.left = `${x}px`;
    this.contextMenu.style.top = `${y}px`;
  }

  hideContextMenu() {
    this.contextMenu.classList.add("hidden");
  }

  showCanvasContextMenu(x, y) {
    this.hideContextMenu(); // Esconde menu de card se estiver aberto
    this.contextMenuPosition = { x, y }; // Save position for item creation
    this.canvasContextMenu.classList.remove("hidden");
    this.canvasContextMenu.style.left = `${x}px`;
    this.canvasContextMenu.style.top = `${y}px`;
  }

  hideCanvasContextMenu() {
    this.canvasContextMenu.classList.add("hidden");
    this.contextMenuPosition = { x: 0, y: 0 };
  }

  // ==========================================
  // Modal
  // ==========================================

  openModal(card) {
    this.selectedCardId = card.id;
    // Suporta formato antigo e novo - faz c√≥pia do array para n√£o modificar o original
    this.selectedCategoryIds = card.categoryIds
      ? [...card.categoryIds]
      : card.categoryId
        ? [card.categoryId]
        : [];
    this.cardModal.classList.remove("hidden");
    this.modalTitle.textContent = card.title ? "Editar Card" : "Novo Card";
    this.cardTitleInput.value = card.title;
    this.cardDetailsInput.value = card.details || "";

    // Renderiza bot√µes de categoria
    this.renderCategoryButtons();

    this.renderChecklistInputs(card.checklists);
  }

  renderCategoryButtons() {
    this.categoryButtons.innerHTML = "";

    this.categories.forEach((cat) => {
      const isSelected = this.selectedCategoryIds.includes(cat.id);
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = `category-btn ${isSelected ? "selected" : ""}`;
      btn.style.backgroundColor = isSelected ? cat.color : "transparent";
      btn.style.borderColor = cat.color;
      btn.style.color = isSelected ? "#fff" : cat.color;
      btn.textContent = cat.name;
      btn.dataset.categoryId = cat.id;

      btn.addEventListener("click", () => {
        if (this.selectedCategoryIds.includes(cat.id)) {
          // Remove a categoria (mant√©m pelo menos uma)
          if (this.selectedCategoryIds.length > 1) {
            this.selectedCategoryIds = this.selectedCategoryIds.filter(
              (id) => id !== cat.id,
            );
          }
        } else {
          // Adiciona a categoria
          this.selectedCategoryIds.push(cat.id);
        }
        this.renderCategoryButtons();
      });

      this.categoryButtons.appendChild(btn);
    });
  }

  closeModal() {
    // Save changes before closing
    if (this.selectedCardId) {
      this.saveCardFromModal();
    } else {
      this.cardModal.classList.add("hidden");
      this.selectedCategoryIds = [];
    }
  }

  renderChecklistInputs(checklists) {
    this.checklistsContainer.innerHTML = "";
    checklists.forEach((checklist) => {
      this.addChecklistInput(checklist);
    });
  }

  addChecklistInput(checklist = null) {
    const id = checklist?.id || this.generateId();
    const div = document.createElement("div");
    div.className = "checklist-item";
    div.dataset.id = id;
    div.draggable = true;

    // Gera op√ß√µes de categorias
    const checklistCategoryId = checklist?.categoryId;
    const categoryOptions = this.categories
      .map(
        (cat) =>
          `<option value="${cat.id}" ${checklistCategoryId !== null && checklistCategoryId !== undefined && String(checklistCategoryId) === String(cat.id) ? "selected" : ""}>${this.escapeHtml(cat.name)}</option>`,
      )
      .join("");

    div.innerHTML = `
      <div class="checklist-item-header">
        <span class="checklist-drag-handle" title="Arrastar para reordenar">‚ãÆ‚ãÆ</span>
        <input type="text" class="checklist-name" placeholder="Nome do item" value="${checklist ? this.escapeHtml(checklist.name) : ""}">
        <select class="checklist-category-select" title="Categoria do item">
          <option value="">Sem categoria</option>
          ${categoryOptions}
        </select>
        <button class="btn-toggle-details" title="Descri√ß√£o">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/>
            <path d="m15 5 4 4"/>
          </svg>
        </button>
        <button class="btn-remove-checklist" title="Remover">&times;</button>
      </div>
      <div class="checklist-item-details ${checklist?.details ? "" : "hidden"}">
        <textarea class="checklist-details" placeholder="Descri√ß√£o do item (aparece ao passar o mouse)">${checklist?.details ? this.escapeHtml(checklist.details) : ""}</textarea>
      </div>
    `;

    div.querySelector(".btn-remove-checklist").addEventListener("click", () => {
      div.remove();
    });

    div.querySelector(".btn-toggle-details").addEventListener("click", () => {
      const detailsDiv = div.querySelector(".checklist-item-details");
      detailsDiv.classList.toggle("hidden");
    });

    // Drag and drop events for reordering
    div.addEventListener("dragstart", (e) => {
      div.classList.add("dragging");
      e.dataTransfer.effectAllowed = "move";
      e.dataTransfer.setData("text/plain", id);
    });

    div.addEventListener("dragend", () => {
      div.classList.remove("dragging");
    });

    div.addEventListener("dragover", (e) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = "move";
      const draggingItem = this.checklistsContainer.querySelector(".dragging");
      if (draggingItem && draggingItem !== div) {
        const rect = div.getBoundingClientRect();
        const midY = rect.top + rect.height / 2;
        if (e.clientY < midY) {
          div.parentNode.insertBefore(draggingItem, div);
        } else {
          div.parentNode.insertBefore(draggingItem, div.nextSibling);
        }
      }
    });

    this.checklistsContainer.appendChild(div);
  }

  saveCardFromModal() {
    const card = this.cards.find((c) => c.id === this.selectedCardId);
    if (!card) return;

    // Salva categorias selecionadas (m√∫ltiplas) - faz c√≥pia do array
    const categoryIds =
      this.selectedCategoryIds.length > 0
        ? [...this.selectedCategoryIds]
        : [this.categories[0]?.id].filter(Boolean);

    card.title = this.cardTitleInput.value || "Sem t√≠tulo";
    card.categoryIds = categoryIds;
    // Mant√©m compatibilidade com formato antigo
    card.categoryId = categoryIds[0] || null;
    card.category =
      this.categories.find((c) => c.id === categoryIds[0])?.name || "Geral";
    card.color = this.getCardPrimaryColor(card);
    card.details = this.cardDetailsInput.value || "";

    // Coleta checklists preservando dados existentes
    const oldChecklists = [...card.checklists];
    card.checklists = [];
    this.checklistsContainer
      .querySelectorAll(".checklist-item")
      .forEach((item) => {
        const name =
          item.querySelector(".checklist-name")?.value ||
          item.querySelector('input[type="text"]').value;
        const detailsTextarea = item.querySelector(".checklist-details");
        const details = detailsTextarea ? detailsTextarea.value : "";
        const categorySelect = item.querySelector(".checklist-category-select");
        const categoryId =
          categorySelect && categorySelect.value !== ""
            ? categorySelect.value
            : null;

        if (name.trim()) {
          // Preserva o estado completed do checklist existente
          const existingChecklist = oldChecklists.find(
            (c) => c.id === item.dataset.id,
          );
          card.checklists.push({
            id: item.dataset.id,
            name: name.trim(),
            details: details.trim(),
            completed: existingChecklist?.completed || false,
            categoryId: categoryId,
          });
        }
      });

    this.renderCard(card);
    this.renderConnections();
    this.saveData();
    // Close modal and clean up
    this.cardModal.classList.add("hidden");
    this.selectedCardId = null;
    this.selectedCategoryIds = [];
  }

  editSelectedCard() {
    this.hideContextMenu();
    const card = this.cards.find((c) => c.id === this.selectedCardId);
    if (card) {
      this.openModal(card);
    }
  }

  deleteSelectedCard() {
    this.hideContextMenu();
    const cardIdToDelete = this.selectedCardId;
    this.cardModal.classList.add("hidden"); // Fecha modal sem limpar selectedCardId
    if (cardIdToDelete) {
      this.deleteCard(cardIdToDelete);
      this.selectedCardId = null;
      this.selectedCategoryIds = [];
    }
  }

  // ==========================================
  // Zoom & Pan
  // ==========================================

  adjustZoom(delta) {
    this.zoom = Math.max(0.1, this.zoom + delta);
    this.applyTransform();
  }

  applyTransform() {
    const transform = `translate(${this.pan.x}px, ${this.pan.y}px) scale(${this.zoom})`;
    this.cardsContainer.style.transform = transform;
    this.connectionsLayer.style.transform = transform;
  }

  resetView() {
    this.zoom = 1;
    this.pan = { x: 0, y: 0 };
    this.applyTransform();
  }

  // ==========================================
  // Theme Management
  // ==========================================

  toggleTheme() {
    const html = document.documentElement;
    const currentTheme = html.getAttribute("data-theme");
    const newTheme = currentTheme === "light" ? "dark" : "light";

    html.setAttribute("data-theme", newTheme === "dark" ? "" : "light");

    // Toggle icons
    if (newTheme === "light") {
      this.themeIconDark.classList.add("hidden");
      this.themeIconLight.classList.remove("hidden");
    } else {
      this.themeIconDark.classList.remove("hidden");
      this.themeIconLight.classList.add("hidden");
    }

    // Salva prefer√™ncia
    localStorage.setItem("visualdoc-theme", newTheme);
  }

  loadTheme() {
    const savedTheme = localStorage.getItem("visualdoc-theme") || "dark";
    const html = document.documentElement;

    if (savedTheme === "light") {
      html.setAttribute("data-theme", "light");
      this.themeIconDark.classList.add("hidden");
      this.themeIconLight.classList.remove("hidden");
    } else {
      html.removeAttribute("data-theme");
      this.themeIconDark.classList.remove("hidden");
      this.themeIconLight.classList.add("hidden");
    }
  }

  // ==========================================
  // Project Management
  // ==========================================

  async newProject() {
    // Salva o projeto atual primeiro
    if (this.projectName) {
      await this.saveData();
    }

    // Pede nome do novo projeto
    const name = await this.promptProjectName();
    if (!name) return;

    // Remove caracteres inv√°lidos
    const safeName = name.replace(/[<>:"/\\|?*]/g, "-");

    await window.electronAPI.setProjectName(safeName);
    this.projectName = safeName;

    // Limpa tudo
    this.cards = [];
    this.connections = [];
    this.currentProjectPath = null;

    // Inicializa hist√≥rico
    this.history = [
      {
        cards: [],
        connections: [],
      },
    ];
    this.historyIndex = 0;

    this.render();
    this.resetView();
    this.saveData();
  }

  promptProjectName() {
    return new Promise((resolve) => {
      const modalOverlay = document.createElement("div");
      modalOverlay.className = "modal";
      modalOverlay.innerHTML = `
        <div class="modal-content" style="max-width: 400px;">
          <div class="modal-header">
            <h2>Novo Projeto</h2>
          </div>
          <div class="modal-body" style="padding: 20px;">
            <div class="form-group">
              <label>Nome do Projeto:</label>
              <input type="text" id="prompt-project-name" class="form-input" 
                     placeholder="Digite o nome do projeto..." 
                     style="width: 100%; padding: 10px; margin-top: 8px;">
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
              <button id="btn-prompt-create" class="btn btn-primary" style="flex: 1;">
                Criar
              </button>
              <button id="btn-prompt-cancel" class="btn btn-secondary" style="flex: 1;">
                Cancelar
              </button>
            </div>
          </div>
        </div>
      `;

      document.body.appendChild(modalOverlay);

      const nameInput = modalOverlay.querySelector("#prompt-project-name");
      const createBtn = modalOverlay.querySelector("#btn-prompt-create");
      const cancelBtn = modalOverlay.querySelector("#btn-prompt-cancel");

      setTimeout(() => nameInput.focus(), 100);

      createBtn.addEventListener("click", () => {
        const name = nameInput.value.trim();
        modalOverlay.remove();
        resolve(name || null);
      });

      cancelBtn.addEventListener("click", () => {
        modalOverlay.remove();
        resolve(null);
      });

      nameInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          const name = nameInput.value.trim();
          modalOverlay.remove();
          resolve(name || null);
        }
        if (e.key === "Escape") {
          modalOverlay.remove();
          resolve(null);
        }
      });
    });
  }

  async loadProject() {
    try {
      const result = await window.electronAPI.loadProject();
      if (result.success && result.data) {
        this.cards = result.data.cards || [];
        this.connections = result.data.connections || [];
        if (result.data.categories && result.data.categories.length > 0) {
          this.categories = result.data.categories;
        }
        this.currentProjectPath = result.filePath;
        this.projectName = result.projectName;

        // Inicializa hist√≥rico
        this.history = [
          {
            cards: JSON.parse(JSON.stringify(this.cards)),
            connections: JSON.parse(JSON.stringify(this.connections)),
          },
        ];
        this.historyIndex = 0;

        this.render();
        this.resetView();
      }
    } catch (error) {
      console.error("Erro ao carregar projeto:", error);
    }
  }

  async saveProjectAs() {
    try {
      const data = {
        cards: this.cards,
        connections: this.connections,
        categories: this.categories,
        lastModified: new Date().toISOString(),
      };

      const result = await window.electronAPI.saveProjectAs(data);
      if (result.success) {
        this.currentProjectPath = result.filePath;
        this.saveStatus.textContent = "‚úì Projeto salvo";
      }
    } catch (error) {
      console.error("Erro ao salvar projeto:", error);
    }
  }

  // ==========================================
  // Export
  // ==========================================

  async exportSVG() {
    const svgContent = this.generateSVG();
    await window.electronAPI.exportSVG(svgContent);
  }

  generateSVG() {
    // Calcula bounds baseado no tamanho real dos cards
    let minX = Infinity,
      minY = Infinity,
      maxX = -Infinity,
      maxY = -Infinity;

    this.cards.forEach((card) => {
      const cardWidth = card.width || 280;
      const cardHeight =
        card.height || Math.max(120, 80 + card.checklists.length * 22);
      minX = Math.min(minX, card.x);
      minY = Math.min(minY, card.y);
      maxX = Math.max(maxX, card.x + cardWidth);
      maxY = Math.max(maxY, card.y + cardHeight);
    });

    const padding = 50;
    const width = maxX - minX + padding * 2;
    const height = maxY - minY + padding * 2;
    const offsetX = -minX + padding;
    const offsetY = -minY + padding;

    let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
  <defs>
    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" fill="#6c5ce7"/>
    </marker>
  </defs>
  
  <rect width="100%" height="100%" fill="#0f0f1a"/>
  
  <!-- Connections -->
  <g id="connections">`;

    // Desenha conex√µes
    this.connections.forEach((conn) => {
      const fromCard = this.cards.find((c) => c.id === conn.from);
      const toCard = this.cards.find((c) => c.id === conn.to);

      if (fromCard && toCard) {
        const fromCardWidth = fromCard.width || 280;
        const fromCardHeight =
          fromCard.height ||
          Math.max(120, 80 + fromCard.checklists.length * 22);
        const toCardHeight =
          toCard.height || Math.max(120, 80 + toCard.checklists.length * 22);

        const fromX = fromCard.x + fromCardWidth + offsetX;
        const fromY = fromCard.y + fromCardHeight / 2 + offsetY;
        const toX = toCard.x + offsetX;
        const toY = toCard.y + toCardHeight / 2 + offsetY;
        const midX = (fromX + toX) / 2;

        svg += `
    <path d="M ${fromX} ${fromY} C ${midX} ${fromY}, ${midX} ${toY}, ${toX} ${toY}" 
          stroke="${fromCard.color}" stroke-width="3" fill="none" 
          stroke-linecap="round" marker-end="url(#arrowhead)"/>`;
      }
    });

    svg += `
  </g>
  
  <!-- Cards -->
  <g id="cards">`;

    // Desenha cards
    this.cards.forEach((card) => {
      const x = card.x + offsetX;
      const y = card.y + offsetY;
      const cardWidth = card.width || 280;
      const cardHeight =
        card.height || Math.max(120, 80 + card.checklists.length * 22);
      const completedCount = card.checklists.filter((c) => c.completed).length;
      const totalCount = card.checklists.length;
      const progress = totalCount > 0 ? (completedCount / totalCount) * 100 : 0;

      svg += `
    <g transform="translate(${x}, ${y})">
      <rect width="${cardWidth}" height="${cardHeight}" rx="12" fill="#1a1a2e" stroke="${card.color}" stroke-width="2"/>
      <text x="15" y="28" fill="#ffffff" font-family="Segoe UI, sans-serif" font-size="16" font-weight="600">${this.escapeHtml(card.title)}</text>
      <rect x="15" y="38" width="80" height="18" rx="9" fill="${card.color}" opacity="0.2"/>
      <text x="25" y="51" fill="${card.color}" font-family="Segoe UI, sans-serif" font-size="10" font-weight="500">${this.escapeHtml(card.category.toUpperCase())}</text>`;

      // Desenha cada item do checklist
      if (card.checklists.length > 0) {
        card.checklists.forEach((item, index) => {
          const itemY = 70 + index * 22;
          const textColor = item.completed ? "#6b7280" : "#e5e7eb";
          const checkColor = item.completed ? "#2ecc71" : "#4b5563";

          // Checkbox
          svg += `
      <rect x="15" y="${itemY}" width="14" height="14" rx="3" fill="${checkColor}" opacity="0.3" stroke="${checkColor}" stroke-width="1"/>`;

          // Checkmark se completado
          if (item.completed) {
            svg += `
      <path d="M ${18} ${itemY + 7} l 3 3 l 5 -6" stroke="#2ecc71" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>`;
          }

          // Texto do item
          const textDecoration = item.completed ? "line-through" : "none";
          svg += `
      <text x="35" y="${itemY + 11}" fill="${textColor}" font-family="Segoe UI, sans-serif" font-size="12" text-decoration="${textDecoration}">${this.escapeHtml(item.name)}</text>`;
        });

        // Barra de progresso no final
        const progressY = 70 + card.checklists.length * 22 + 5;
        svg += `
      <rect x="15" y="${progressY}" width="${cardWidth - 30}" height="4" rx="2" fill="#25253a"/>
      <rect x="15" y="${progressY}" width="${(progress / 100) * (cardWidth - 30)}" height="4" rx="2" fill="#2ecc71"/>`;
      }

      svg += `
    </g>`;
    });

    svg += `
  </g>
</svg>`;

    return svg;
  }

  // ==========================================
  // Rendering
  // ==========================================

  render() {
    this.cardsContainer.innerHTML = "";
    // Render columns FIRST so they stay behind cards and texts
    this.columns.forEach((column) => this.renderColumn(column));
    this.cards.forEach((card) => this.renderCard(card));
    this.texts.forEach((text) => this.renderText(text));
    this.renderConnections();
  }

  // ==========================================
  // Categories Management
  // ==========================================

  openCategoriesModal() {
    this.categoriesModal.classList.remove("hidden");
    this.renderCategoriesList();
    this.newCategoryName.value = "";
    this.newCategoryColor.value = "#6366f1";
  }

  closeCategoriesModal() {
    this.categoriesModal.classList.add("hidden");
  }

  renderCategoriesList() {
    this.categoriesList.innerHTML = "";

    this.categories.forEach((cat) => {
      const item = document.createElement("div");
      item.className = "category-list-item";
      item.innerHTML = `
        <input type="color" class="category-color-input" value="${cat.color}" title="Alterar cor">
        <input type="text" class="category-name-input" value="${this.escapeHtml(cat.name)}" placeholder="Nome da categoria">
        <button class="btn-delete-category" data-id="${cat.id}" title="Excluir">&times;</button>
      `;

      // Event listener para mudan√ßa de cor
      item
        .querySelector(".category-color-input")
        .addEventListener("change", (e) => {
          cat.color = e.target.value;
          this.updateCardsWithCategory(cat.id);
          this.saveData();
        });

      // Event listener para mudan√ßa de nome
      item
        .querySelector(".category-name-input")
        .addEventListener("change", (e) => {
          cat.name = e.target.value.trim() || "Sem nome";
          this.updateCardsWithCategory(cat.id);
          this.saveData();
        });

      item
        .querySelector(".btn-delete-category")
        .addEventListener("click", () => {
          this.deleteCategory(cat.id);
        });

      this.categoriesList.appendChild(item);
    });
  }

  updateCardsWithCategory(categoryId) {
    // Atualiza todos os cards que usam essa categoria
    this.cards.forEach((card) => {
      const ids =
        card.categoryIds || (card.categoryId ? [card.categoryId] : []);
      if (ids.includes(categoryId)) {
        card.color = this.getCardPrimaryColor(card);
        card.category =
          this.categories.find((c) => c.id === card.categoryId)?.name ||
          "Geral";
        this.renderCard(card);
      }
    });
    this.renderConnections();
  }

  addCategory() {
    const name = this.newCategoryName.value.trim();
    const color = this.newCategoryColor.value;

    if (!name) {
      alert("Digite um nome para a categoria.");
      return;
    }

    const newCategory = {
      id: "cat_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9),
      name: name,
      color: color,
    };

    this.categories.push(newCategory);
    this.newCategoryName.value = "";
    this.newCategoryColor.value = "#6366f1";
    this.renderCategoriesList();
    this.saveData();
  }

  deleteCategory(categoryId) {
    // N√£o permite excluir se houver apenas uma categoria
    if (this.categories.length <= 1) {
      alert("Voc√™ precisa ter pelo menos uma categoria.");
      return;
    }

    // Verifica se h√° cards usando essa categoria
    const cardsUsingCategory = this.cards.filter((c) => {
      const ids = c.categoryIds || (c.categoryId ? [c.categoryId] : []);
      return ids.includes(categoryId);
    });

    if (cardsUsingCategory.length > 0) {
      if (
        !confirm(
          `Existem ${cardsUsingCategory.length} card(s) usando esta categoria. Deseja excluir mesmo assim? A categoria ser√° removida dos cards.`,
        )
      ) {
        return;
      }

      // Remove a categoria dos cards
      const firstCategory = this.categories.find((c) => c.id !== categoryId);
      cardsUsingCategory.forEach((card) => {
        card.categoryIds = (card.categoryIds || [card.categoryId]).filter(
          (id) => id !== categoryId,
        );
        // Se ficou sem categorias, adiciona a primeira dispon√≠vel
        if (card.categoryIds.length === 0) {
          card.categoryIds = [firstCategory.id];
        }
        card.categoryId = card.categoryIds[0];
        card.category =
          this.categories.find((c) => c.id === card.categoryId)?.name ||
          "Geral";
        card.color = this.getCardPrimaryColor(card);
        this.renderCard(card);
      });
    }

    this.categories = this.categories.filter((c) => c.id !== categoryId);
    this.renderCategoriesList();
    this.saveData();
  }

  // ==========================================
  // Multi-sele√ß√£o e Copiar/Colar
  // ==========================================

  clearSelection() {
    // Clear all selected items (cards, texts, columns)
    this.selectedItemIds.forEach(({ id, type }) => {
      const prefix =
        type === "card" ? "card" : type === "text" ? "text" : "column";
      const element = document.getElementById(`${prefix}-${id}`);
      if (element) {
        element.classList.remove("selected", "dragging");
      }
    });

    // Clear legacy card selection
    this.selectedCardIds.forEach((cardId) => {
      const cardElement = document.getElementById(`card-${cardId}`);
      if (cardElement) {
        cardElement.classList.remove("selected", "dragging");
      }
    });

    this.selectedItemIds = [];
    this.selectedItemId = null;
    this.selectedItemType = null;
    this.selectedCardIds = [];
    this.selectedCardId = null;

    // Also deselect connections
    if (this.selectedConnectionIndex !== null) {
      this.selectedConnectionIndex = null;
      this.renderConnections();
    }
  }

  selectAllCards() {
    this.clearSelection();
    this.selectedCardIds = this.cards.map((c) => c.id);
    this.selectedItemIds = this.cards.map((c) => ({ id: c.id, type: "card" }));
    this.selectedCardIds.forEach((cardId) => {
      const cardElement = document.getElementById(`card-${cardId}`);
      if (cardElement) {
        cardElement.classList.add("selected");
      }
    });
  }

  copySelectedCards() {
    if (this.selectedCardIds.length === 0) return;

    // Copia os cards selecionados (deep copy)
    this.clipboard = this.selectedCardIds
      .map((cardId) => {
        const card = this.cards.find((c) => c.id === cardId);
        if (card) {
          return JSON.parse(JSON.stringify(card));
        }
        return null;
      })
      .filter(Boolean);

    // Feedback visual
    const saveStatus = document.getElementById("save-status");
    if (saveStatus) {
      saveStatus.textContent = `üìã ${this.clipboard.length} card(s) copiado(s)`;
      setTimeout(() => {
        saveStatus.textContent = "‚úì Salvo";
      }, 1500);
    }
  }

  pasteCards() {
    if (this.clipboard.length === 0) return;

    const offset = 30; // Offset para n√£o sobrepor exatamente
    const newCards = [];

    this.clipboard.forEach((cardData, index) => {
      const newCard = {
        ...cardData,
        id: this.generateId(),
        x: cardData.x + offset + index * 10,
        y: cardData.y + offset + index * 10,
        checklists: cardData.checklists.map((cl) => ({
          ...cl,
          id: this.generateId(),
        })),
      };
      this.cards.push(newCard);
      newCards.push(newCard);
    });

    // Renderiza os novos cards
    newCards.forEach((card) => this.renderCard(card));

    // Seleciona os novos cards
    this.clearSelection();
    this.selectedCardIds = newCards.map((c) => c.id);
    this.selectedCardIds.forEach((cardId) => {
      const cardElement = document.getElementById(`card-${cardId}`);
      if (cardElement) {
        cardElement.classList.add("selected");
      }
    });

    this.renderConnections();
    this.saveData();

    // Feedback visual
    const saveStatus = document.getElementById("save-status");
    if (saveStatus) {
      saveStatus.textContent = `üìã ${newCards.length} card(s) colado(s)`;
      setTimeout(() => {
        saveStatus.textContent = "‚úì Salvo";
      }, 1500);
    }
  }

  deleteSelectedItems() {
    if (this.selectedItemIds.length === 0) return;

    const count = this.selectedItemIds.length;
    if (!confirm(`Deseja excluir ${count} item(s) selecionado(s)?`)) {
      return;
    }

    // Remove each selected item
    this.selectedItemIds.forEach(({ id, type }) => {
      this.deleteItem(id, type);
    });

    this.clearSelection();
  }

  // Legacy alias
  deleteSelectedCards() {
    this.deleteSelectedItems();
  }

  // ==========================================
  // Utilities
  // ==========================================

  generateId() {
    return "card_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9);
  }

  getCardCategories(card) {
    // Suporta formato antigo (categoryId √∫nico) e novo (categoryIds array)
    const categoryIds =
      card.categoryIds || (card.categoryId ? [card.categoryId] : []);
    return categoryIds
      .map((id) => this.categories.find((c) => c.id === id))
      .filter(Boolean);
  }

  getCardPrimaryColor(card) {
    const categories = this.getCardCategories(card);
    return categories.length > 0 ? categories[0].color : "#6366f1";
  }

  getRandomColor() {
    const colors = [
      "#6c5ce7",
      "#00b894",
      "#0984e3",
      "#e17055",
      "#fdcb6e",
      "#e84393",
      "#00cec9",
      "#a29bfe",
    ];
    return colors[Math.floor(Math.random() * colors.length)];
  }

  escapeHtml(text) {
    const div = document.createElement("div");
    div.textContent = text;
    return div.innerHTML;
  }
}

// Inicializa a aplica√ß√£o
document.addEventListener("DOMContentLoaded", () => {
  window.visualDocApp = new VisualDocApp();
});
